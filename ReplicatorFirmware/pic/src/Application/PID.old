/**
 * PID.c
 *
 *  Created on: Aug 8, 2009
 *      Author: hephaestus
 */

#include "UserApp.h"

static DYIO_PID pidChans[NUM_PID_GROUPS];
extern DATA_STRUCT DATA __attribute__ ((section (".scs_global_var")));

void getPosition(DYIO_PID * chan);
void setVelocity(DYIO_PID * chan);
void updateAsync(BYTE i);
void runCalc(DYIO_PID * state);
void pidReset(DYIO_PID * state,BYTE chan,INT32 value);
static RunEveryData force[NUM_PID_GROUPS];

void fail(){
	while(TRUE){
		SetColor(1,1,0);
		buttonCheck();
	}
}

#if defined(USE_VELOCITY)
/**
 * PD velocity code
 */
typedef struct __attribute__((__packed__)) _PD_VEL
{
	BOOL enabled;
	float unitsPerSecond;
	INT32 lastPosition;
	float lastVelocity;
	float lastTime;
	float currentOutputVel;
} PD_VEL;
static PD_VEL vel[NUM_PID_GROUPS];

void RunPDVel(BYTE chan){
	if(vel[chan].enabled==TRUE){
		int currentPosition = GetPID(chan);
		float currentTime = getMs();
		float timeMsDiff =  (currentTime -vel[chan].lastTime);
		float timeDiff =  timeMsDiff/1000;
		int posDiff=currentPosition-vel[chan].lastPosition;
		float currentVelocity = posDiff/timeDiff;
		//float velocityDiff = currentVelocity-vel[chan].lastVelocity;
		float velocityDiff=0;
		float proportional =  currentVelocity-vel[chan].unitsPerSecond;
		float set = (vel[chan].currentOutputVel+(proportional*pidChans[chan].pid.K.P)+(velocityDiff*pidChans[chan].pid.K.D))/-10;
		vel[chan].currentOutputVel+=set;

		if (vel[chan].currentOutputVel>100)
			vel[chan].currentOutputVel=100;
		if(vel[chan].currentOutputVel<-100)
			vel[chan].currentOutputVel=-100;

		println("Velocity set=");p_fl(vel[chan].unitsPerSecond);print(" ticks/second");
		println("Velocity position diff=");p_sl(posDiff);print(" ticks");
		println("Velocity time diff=");p_fl(timeDiff);print(" seconds");
		println("Velocity time diff=");p_fl(timeMsDiff);print(" ms");
		println("Velocity current=");p_fl(currentVelocity);print(" ticks/second");
		println("Velocity offset=");p_fl(set);print("\n");
		println("Velocity set=");p_fl(vel[chan].currentOutputVel);print("\n");

		pidChans[chan].pid.Output=vel[chan].currentOutputVel;
		setVelocity(& pidChans[chan]);
		//cleanup
		vel[chan].lastPosition=currentPosition;
		vel[chan].lastVelocity=currentVelocity;
		vel[chan].lastTime=currentTime;
	}
}

void StartPDVel(BYTE chan,INT32 unitsPerSecond,float ms){
	if(ms<.1){
		vel[chan].enabled=TRUE;
		pidChans[chan].Enabled=FALSE;
		vel[chan].lastPosition=GetPID(chan);
		vel[chan].lastTime=getMs();
		vel[chan].unitsPerSecond=unitsPerSecond;
		vel[chan].currentOutputVel =0;
	}else{
		float seconds = ms/1000;
		INT32 dist = (INT32)unitsPerSecond*(INT32)seconds;
		INT32 delt = ((INT32) (GetPID(chan))-dist);
		SetPIDTimed(chan, delt, ms);
	}
}

void RunVel(void){
	BYTE i;
	for (i=0;i<NUM_PID_GROUPS;i++){
		if(!pidChans[i].Enabled){
			RunPDVel(i);
		}
		updateAsync( i);
	}
}


/**
 * END PD velocity code
 */
#endif

void initPIDChans(BYTE chan){
	switch(pidChans[chan].inputMode & 0x7F){
	case IS_COUNTER_INPUT_INT:
	case IS_COUNTER_INPUT_DIR:
	case IS_COUNTER_INPUT_HOME:
		pidChans[chan].inputChannel = getCounterIntChannnel( channelToCounterGroup(chan));
		StartCounterInput(pidChans[chan].inputChannel);
	}

	println("Setting Modes for PID");
	SetCoProcMode(pidChans[chan].inputChannel,pidChans[chan].inputMode|0x80);
	SetCoProcMode(pidChans[chan].outputChannel,pidChans[chan].outputMode);
	SyncModes();

	if(pidChans[chan].inputMode== IS_ANALOG_IN){
		pidChans[chan].pid.SetPoint=GetAnalogValFromAsync(pidChans[chan].inputChannel);
	}else{
		pidChans[chan].pid.SetPoint=0;
	}
}

BYTE ResetPID(BYTE chan, INT32 value){
#if defined(USE_VELOCITY)
	vel[chan].enabled=FALSE;
#endif
	println("From Reset 1 Current setpoint:");p_fl(pidChans[chan].pid.SetPoint); print(" Target value:");p_sl(value);
	if(pidChans[chan].inputMode == IS_COUNTER_INPUT_INT){
		SetCounterInput(pidChans[chan].inputChannel,value);
	}else if(pidChans[chan].inputMode == IS_ANALOG_IN){
		value=GetAnalogValFromAsync(pidChans[chan].inputChannel);
	}
	println("From Reset 2 Current setpoint:");p_fl(pidChans[chan].pid.SetPoint); print(" Target value:");p_sl(value);
	pidReset(&pidChans[chan],chan,value);
	return TRUE;
}

void pidReset(DYIO_PID * state,BYTE chan,INT32 val){
	float value = (float)val;
	println("From pidReset 1 Current setpoint:");p_fl(pidChans[chan].pid.SetPoint); print(" Target value:");p_fl(value);
	float time = getMs();
	state->channel=chan;
	state->lastPushed=value;
	InitAbsPIDWithPosition(&state->pid,state->pid.K.P,state->pid.K.I,state->pid.K.D, time,value );
	println("From pidReset 2 Current setpoint:");p_fl(pidChans[chan].pid.SetPoint);
	state->interpolate.set=value;
	state->interpolate.setTime=0;
	state->interpolate.start=value;
	state->interpolate.startTime=time;
	state->pid.SetPoint=value;
	print("\nRe-setting PID ");p_fl(value);
#if defined(USE_VELOCITY)
	vel[chan].enabled=FALSE;
#endif
}

void InitPID(void){

	BYTE i;
	//WORD loop;
	for (i=0;i<NUM_PID_GROUPS;i++){
		pidChans[i].inputChannel=0;
		pidChans[i].outputChannel=0;
		pidChans[i].inputMode=0;
		pidChans[i].outputMode=0;
		pidChans[i].Enabled=FALSE;
		pidChans[i].channel = i;
#if defined(USE_VELOCITY)
		vel[i].enabled=FALSE;
#endif
		LoadPIDvals(&pidChans[i]);
		printPIDvals(&pidChans[i]);
		force[i].MsTime=0;
		force[i].setPoint=200;
		if(pidChans[i].Enabled){
			initPIDChans(i);
			println("Resetting PID channel from init");
			ResetPID(i,0);
		}

		pidChans[i].Enabled=FALSE;
	}

}

void GetConfigPID(BowlerPacket * Packet){
	BYTE chan = Packet->use.data[0];
	Packet->use.data[1]=pidChans[chan].Enabled;//  = ((Packet->use.data[1]==0)?0:1);
	Packet->use.data[2]=pidChans[chan].Polarity;// = ((Packet->use.data[2]==0)?0:1);
	Packet->use.data[3]=pidChans[chan].Async;//= ((Packet->use.data[3]==0)?0:1);

	INT32_UNION PID_K;
	PID_K.Val=pidChans[chan].pid.K.P*100;
	Packet->use.data[4]=PID_K.byte.FB;//=Packet->use.data[4];
	Packet->use.data[5]=PID_K.byte.TB;//Packet->use.data[5];
	Packet->use.data[6]=PID_K.byte.SB;//Packet->use.data[6];
	Packet->use.data[7]=PID_K.byte.LB;//Packet->use.data[7];

	PID_K.Val=pidChans[chan].pid.K.I*100;
	Packet->use.data[8]=PID_K.byte.FB;//Packet->use.data[8];
	Packet->use.data[9]=PID_K.byte.TB;//Packet->use.data[9];
	Packet->use.data[10]=PID_K.byte.SB;//Packet->use.data[10];
	Packet->use.data[11]=PID_K.byte.LB;//Packet->use.data[11];

	PID_K.Val=pidChans[chan].pid.K.D*100;
	Packet->use.data[12]=PID_K.byte.FB;//Packet->use.data[12];
	Packet->use.data[13]=PID_K.byte.TB;//Packet->use.data[13];
	Packet->use.data[14]=PID_K.byte.SB;//Packet->use.data[14];
	Packet->use.data[15]=PID_K.byte.LB;//Packet->use.data[15];
	Packet->use.head.DataLegnth=4+4+(3*4);
	Packet->use.head.Method=BOWLER_POST;

}

BYTE ConfigPID(BowlerPacket * Packet){
	BYTE chan = Packet->use.data[0];

	pidChans[chan].Polarity = ((Packet->use.data[2]==0)?0:1);
	pidChans[chan].Async    = ((Packet->use.data[3]==0)?0:1);


	float KP=0;
	float KI=0;
	float KD=0;
	INT32_UNION PID_K;

	PID_K.byte.FB=Packet->use.data[4];
	PID_K.byte.TB=Packet->use.data[5];
	PID_K.byte.SB=Packet->use.data[6];
	PID_K.byte.LB=Packet->use.data[7];
	KP=(float)PID_K.Val;

	PID_K.byte.FB=Packet->use.data[8];
	PID_K.byte.TB=Packet->use.data[9];
	PID_K.byte.SB=Packet->use.data[10];
	PID_K.byte.LB=Packet->use.data[11];
	KI=(float)PID_K.Val;

	PID_K.byte.FB=Packet->use.data[12];
	PID_K.byte.TB=Packet->use.data[13];
	PID_K.byte.SB=Packet->use.data[14];
	PID_K.byte.LB=Packet->use.data[15];
	KD=(float)PID_K.Val;


	pidChans[chan].pid.K.P=KP/100;
	pidChans[chan].pid.K.I=KI/100;
	pidChans[chan].pid.K.D=KD/100;
	println("Resetting PID channel from config:");printBowlerPacketDEBUG(Packet);
	println("From config Current setpoint:");p_fl(pidChans[chan].pid.SetPoint);
	ResetPID(chan, pidChans[chan].pid.SetPoint);

	pidChans[chan].pid.Output=0;
	setVelocity(&pidChans[chan]);

	pidChans[chan].Enabled  = ((Packet->use.data[1]==0)?0:1);
	WritePIDvalues(&pidChans[chan]);

//	if(pidChans[chan].Enabled)
//		fail();
	return TRUE;
}
void GetConfigDyPID(BowlerPacket * Packet){
	BYTE chan = Packet->use.data[0];
	Packet->use.data[1]=pidChans[chan].inputChannel;// =Packet->use.data[1];
	Packet->use.data[2]=pidChans[chan].inputMode ;//Packet->use.data[2];
	Packet->use.data[3]=pidChans[chan].outputChannel;//Packet->use.data[3];
	Packet->use.data[4]=pidChans[chan].outputMode;//Packet->use.data[4];
	Packet->use.head.DataLegnth=4+5;
	Packet->use.head.Method=BOWLER_POST;

}
BYTE ConfigDyPID(BowlerPacket * Packet){
	BYTE chan = Packet->use.data[0];
	pidChans[chan].inputChannel =Packet->use.data[1];
	pidChans[chan].inputMode =Packet->use.data[2];
	pidChans[chan].outputChannel =Packet->use.data[3];
	pidChans[chan].outputMode =Packet->use.data[4];

	initPIDChans(chan);

	WritePIDvalues(&pidChans[chan]);
	return TRUE;
}



BYTE ZeroPID(BYTE chan){
	println("Resetting PID channel from zeroPID:");
	return ResetPID(chan,0);
}

BYTE ClearPID(BYTE chan){
	if (chan>=NUM_PID_GROUPS)
		return FALSE;
	pidChans[chan].Enabled=FALSE;
	return TRUE;
}

BYTE SetPIDTimed(BYTE chan,INT32 val,float ms){
	if (chan>=NUM_PID_GROUPS)
		return FALSE;
	if(ms<0)
		ms=0;
	//pidChans[chan].Enabled=TRUE;
	pidChans[chan].interpolate.set=(float)val;
	pidChans[chan].interpolate.setTime=ms;
	pidChans[chan].interpolate.start=pidChans[chan].pid.SetPoint;
	pidChans[chan].interpolate.startTime=getMs();
	if(ms==0)
		pidChans[chan].pid.SetPoint=(float)val;
	pidChans[chan].Enabled=TRUE;
#if defined(USE_VELOCITY)
	vel[chan].enabled=FALSE;
#endif
	InitAbsPIDWithPosition(&pidChans[chan].pid,pidChans[chan].pid.K.P,pidChans[chan].pid.K.I,pidChans[chan].pid.K.D, getMs(),val);
	return TRUE;
}
BYTE SetPID(BYTE chan,INT32 val){
	SetPIDTimed(chan, val,0);
	return TRUE;
}

LONG GetPID(BYTE chan){
	if (chan>=NUM_PID_GROUPS)
		return 0;
	getPosition(& pidChans[chan]);
	return pidChans[chan].pid.CurrentState;
}

void updateAsync(BYTE i){
	if(pidChans[i].Async && (pidChans[i].Enabled
#if defined(USE_VELOCITY)
					||vel[i].enabled
#endif
					)){
		if(pidChans[i].pid.CurrentState != pidChans[i].lastPushed){
			pidChans[i].lastPushed=pidChans[i].pid.CurrentState;
			pushPID(i,(INT32)pidChans[i].lastPushed);
		}
	}
}



BYTE GetPIDGroup(BYTE chan){
	BYTE mode = GetChannelMode(chan);
	BYTE i;
	switch(mode){
	case IS_COUNTER_INPUT_INT:
	case IS_COUNTER_INPUT_DIR:
	case IS_COUNTER_INPUT_HOME:
	case IS_ANALOG_IN:
		for(i=0;i<NUM_PID_GROUPS;i++){
			if(pidChans[i].inputChannel == chan){
				if(pidChans[i].Enabled )
					return i;
			}
		}
		break;
	case IS_SERVO:
	case IS_DC_MOTOR_DIR:
	case IS_DC_MOTOR_VEL:
	case IS_PWM:
		for(i=0;i<NUM_PID_GROUPS;i++){
			if(pidChans[i].outputChannel == chan){
				if(pidChans[i].Enabled )
					return i;
			}
		}
		break;
	default:
		break;
	}
	return NOT_USED_IN_PID;
}

void SetSetpointToCurrent(BYTE chan){

}


void RunPID(void){
	//enableDebug();
	BYTE i;
	for (i=0;i<NUM_PID_GROUPS;i++){
		if(pidChans[i].Enabled){
			pidChans[i].pid.SetPoint = interpolate(&pidChans[i].interpolate,getMs());
			getPosition(& pidChans[i]);
			RunAbstractPIDCalc(& pidChans[i].pid,getMs());
			setVelocity(& pidChans[i]);
		}
		updateAsync( i);
	}
}

void getPosition(DYIO_PID * chan){
	LONG pos = 0;
	//print("\nGetting PID value from group: ");p_ul(chan->channel);print(" of mode: ");printMode(chan->inputMode);print(" From channel: ");p_ul(chan->inputChannel);print("\n");
	switch(chan->inputMode){
	case IS_COUNTER_INPUT_INT:
	case IS_COUNTER_INPUT_DIR:
	case IS_COUNTER_INPUT_HOME:
		pos=GetCounterByChannel( chan->inputChannel );
		break;
	case IS_ANALOG_IN:
		pos=GetAnalogValFromAsync(chan->inputChannel);
		break;
	}
	chan->pid.CurrentState = ((float)pos);
}

void setVelocity(DYIO_PID * chan){
	float val = chan->pid.Output;
	BYTE center = DATA.PIN[chan->outputChannel].ServoPos;
	val*=(chan->Polarity)?1:-1;
	val += center;
	if (val>220.0)
		val=220.0;
	if(val<25.0)
		val=25.0;
	int set = (int)val;
	if (chan->outVal==set){
		//if(!(RunEvery(&force[chan->channel])>0))
			return;
	}else{
		print(" Setting PID output, was ");p_sl(chan->outVal);print(" is now: ");p_sl(set);print(" on DyIO chan: ");p_sl(chan->outputChannel);print(", ");
	}
	chan->outVal=set;
	SetChannelValueCoProc(chan->outputChannel,chan->outVal);
}


